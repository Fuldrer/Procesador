/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule
module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule


module DIG_ROM_256X32_InstMem (
    input [7:0] A,
    input sel,
    output reg [31:0] D
);
    reg [31:0] my_rom [0:9];

    always @ (*) begin
        if (~sel)
            D = 32'hz;
        else if (A > 8'h9)
            D = 32'h0;
        else
            D = my_rom[A];
    end

    initial begin
        my_rom[0] = 32'hdeadbeef;
        my_rom[1] = 32'h11111111;
        my_rom[2] = 32'h22222222;
        my_rom[3] = 32'h33333333;
        my_rom[4] = 32'h44444444;
        my_rom[5] = 32'h55555555;
        my_rom[6] = 32'h66666666;
        my_rom[7] = 32'h77777777;
        my_rom[8] = 32'h88888888;
        my_rom[9] = 32'h99999999;
    end
endmodule


module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule

module PriorityEncoder4 (
    input in0,
    input in1,
    input in2,
    input in3,
    input in4,
    input in5,
    input in6,
    input in7,
    input in8,
    input in9,
    input in10,
    input in11,
    input in12,
    input in13,
    input in14,
    input in15,
    output reg [3:0] num,
    output any
);
    always @ (*) begin
        if (in15 == 1'b1)
            num = 4'hf;
        else if (in14 == 1'b1)
            num = 4'he;
        else if (in13 == 1'b1)
            num = 4'hd;
        else if (in12 == 1'b1)
            num = 4'hc;
        else if (in11 == 1'b1)
            num = 4'hb;
        else if (in10 == 1'b1)
            num = 4'ha;
        else if (in9 == 1'b1)
            num = 4'h9;
        else if (in8 == 1'b1)
            num = 4'h8;
        else if (in7 == 1'b1)
            num = 4'h7;
        else if (in6 == 1'b1)
            num = 4'h6;
        else if (in5 == 1'b1)
            num = 4'h5;
        else if (in4 == 1'b1)
            num = 4'h4;
        else if (in3 == 1'b1)
            num = 4'h3;
        else if (in2 == 1'b1)
            num = 4'h2;
        else if (in1 == 1'b1)
            num = 4'h1;
        else 
            num = 4'h0;
    end

    assign any = in0 | in1 | in2 | in3 | in4 | in5 | in6 | in7 | in8 | in9 | in10 | in11 | in12 | in13 | in14 | in15;
endmodule


module Mux_16x1_NBits #(
    parameter Bits = 2
)
(
    input [3:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    input [(Bits - 1):0] in_8,
    input [(Bits - 1):0] in_9,
    input [(Bits - 1):0] in_10,
    input [(Bits - 1):0] in_11,
    input [(Bits - 1):0] in_12,
    input [(Bits - 1):0] in_13,
    input [(Bits - 1):0] in_14,
    input [(Bits - 1):0] in_15,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            4'h0: out = in_0;
            4'h1: out = in_1;
            4'h2: out = in_2;
            4'h3: out = in_3;
            4'h4: out = in_4;
            4'h5: out = in_5;
            4'h6: out = in_6;
            4'h7: out = in_7;
            4'h8: out = in_8;
            4'h9: out = in_9;
            4'ha: out = in_10;
            4'hb: out = in_11;
            4'hc: out = in_12;
            4'hd: out = in_13;
            4'he: out = in_14;
            4'hf: out = in_15;
            default:
                out = 'h0;
        endcase
    end
endmodule


module control_unit_full (
  input [5:0] opcode,
  input [5:0] func,
  output jump,
  output Branch,
  output MemRead,
  output MemWrite,
  output MemToReg,
  output ALUSrc,
  output RegWrite,
  output RegDst,
  output InvOpcode,
  output [2:0] ALUFunc,
  output Bne
);
  wire lw;
  wire sw;
  wire beq;
  wire jmp;
  wire s_bne;
  wire add;
  wire sub;
  wire slt;
  wire \and ;
  wire \or ;
  wire [3:0] s0;
  wire [12:0] s1;
  wire [5:0] s2;
  wire s3;
  // lw
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i0 (
    .a( opcode ),
    .b( 6'b100011 ),
    .\= ( lw )
  );
  // sw
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i1 (
    .a( opcode ),
    .b( 6'b101011 ),
    .\= ( sw )
  );
  // beq
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i2 (
    .a( opcode ),
    .b( 6'b100 ),
    .\= ( beq )
  );
  // jmp
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i3 (
    .a( opcode ),
    .b( 6'b10 ),
    .\= ( jmp )
  );
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i4 (
    .a( opcode ),
    .b( 6'b0 ),
    .\= ( s3 )
  );
  // bne
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i5 (
    .a( opcode ),
    .b( 6'b101 ),
    .\= ( s_bne )
  );
  Mux_2x1_NBits #(
    .Bits(6)
  )
  Mux_2x1_NBits_i6 (
    .sel( s3 ),
    .in_0( 6'b0 ),
    .in_1( func ),
    .out( s2 )
  );
  // or
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i7 (
    .a( s2 ),
    .b( 6'b100101 ),
    .\= ( \or  )
  );
  // and
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i8 (
    .a( s2 ),
    .b( 6'b100100 ),
    .\= ( \and  )
  );
  // slt
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i9 (
    .a( s2 ),
    .b( 6'b101010 ),
    .\= ( slt )
  );
  // sub
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i10 (
    .a( s2 ),
    .b( 6'b100010 ),
    .\= ( sub )
  );
  // add
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i11 (
    .a( s2 ),
    .b( 6'b100000 ),
    .\= ( add )
  );
  PriorityEncoder4 PriorityEncoder4_i12 (
    .in0( lw ),
    .in1( sw ),
    .in2( beq ),
    .in3( jmp ),
    .in4( s_bne ),
    .in5( add ),
    .in6( sub ),
    .in7( slt ),
    .in8( \and  ),
    .in9( \or  ),
    .in10( 1'b0 ),
    .in11( 1'b0 ),
    .in12( 1'b0 ),
    .in13( 1'b0 ),
    .in14( 1'b0 ),
    .in15( 1'b0 ),
    .num( s0 )
  );
  Mux_16x1_NBits #(
    .Bits(13)
  )
  Mux_16x1_NBits_i13 (
    .sel( s0 ),
    .in_0( 13'b1110100 ),
    .in_1( 13'b101000 ),
    .in_2( 13'b1000000010 ),
    .in_3( 13'b1 ),
    .in_4( 13'b1001000000000 ),
    .in_5( 13'b11000000 ),
    .in_6( 13'b1011000000 ),
    .in_7( 13'b10011000000 ),
    .in_8( 13'b11011000000 ),
    .in_9( 13'b100011000000 ),
    .in_10( 13'b0 ),
    .in_11( 13'b0 ),
    .in_12( 13'b0 ),
    .in_13( 13'b0 ),
    .in_14( 13'b0 ),
    .in_15( 13'b0 ),
    .out( s1 )
  );
  assign jump = s1[0];
  assign Branch = s1[1];
  assign MemRead = s1[2];
  assign MemWrite = s1[3];
  assign MemToReg = s1[4];
  assign ALUSrc = s1[5];
  assign RegWrite = s1[6];
  assign RegDst = s1[7];
  assign InvOpcode = s1[8];
  assign ALUFunc = s1[11:9];
  assign Bne = s1[12];
endmodule
module DIG_BitExtender #(
    parameter inputBits = 2,
    parameter outputBits = 4
)
(
    input [(inputBits-1):0] in,
    output [(outputBits - 1):0] out
);
    assign out = {{(outputBits - inputBits){in[inputBits - 1]}}, in};
endmodule



module DIG_RegisterFile
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
    input [(Bits-1):0] Din,
    input we,
    input [(AddrBits-1):0] Rw,
    input C,
    input [(AddrBits-1):0] Ra,
    input [(AddrBits-1):0] Rb,
    output [(Bits-1):0] Da,
    output [(Bits-1):0] Db
);

    reg [(Bits-1):0] memory[0:((1 << AddrBits)-1)];

    assign Da = memory[Ra];
    assign Db = memory[Rb];

    always @ (posedge C) begin
        if (we)
            memory[Rw] <= Din;
    end
endmodule


module DIG_Sub #(
    parameter Bits = 2
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits-1):0] s,
    output c_o
);
    wire [Bits:0] temp;

    assign temp = a - b - c_i;
    assign s = temp[(Bits-1):0];
    assign c_o = temp[Bits];
endmodule


module CompSigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = $signed(a) > $signed(b);
    assign \= = $signed(a) == $signed(b);
    assign \< = $signed(a) < $signed(b);
endmodule


module Mux_8x1_NBits #(
    parameter Bits = 2
)
(
    input [2:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            3'h0: out = in_0;
            3'h1: out = in_1;
            3'h2: out = in_2;
            3'h3: out = in_3;
            3'h4: out = in_4;
            3'h5: out = in_5;
            3'h6: out = in_6;
            3'h7: out = in_7;
            default:
                out = 'h0;
        endcase
    end
endmodule


module alu (
  input [31:0] a,
  input [31:0] b,
  input [2:0] func,
  output [31:0] res,
  output zero
);
  wire [31:0] s0;
  wire [31:0] s1;
  wire [31:0] s2;
  wire [31:0] s3;
  wire s4;
  wire [31:0] s5;
  wire [31:0] res_temp;
  assign s0 = (a & b);
  assign s1 = (a | b);
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i0 (
    .a( a ),
    .b( b ),
    .c_i( 1'b0 ),
    .s( s2 )
  );
  DIG_Sub #(
    .Bits(32)
  )
  DIG_Sub_i1 (
    .a( a ),
    .b( b ),
    .c_i( 1'b0 ),
    .s( s3 )
  );
  CompSigned #(
    .Bits(32)
  )
  CompSigned_i2 (
    .a( a ),
    .b( b ),
    .\< ( s4 )
  );
  assign s5[0] = s4;
  assign s5[31:1] = 31'b0;
  Mux_8x1_NBits #(
    .Bits(32)
  )
  Mux_8x1_NBits_i3 (
    .sel( func ),
    .in_0( s2 ),
    .in_1( s3 ),
    .in_2( s5 ),
    .in_3( s0 ),
    .in_4( s1 ),
    .in_5( 32'b0 ),
    .in_6( 32'b0 ),
    .in_7( 32'b0 ),
    .out( res_temp )
  );
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i4 (
    .a( res_temp ),
    .b( 32'b0 ),
    .\= ( zero )
  );
  assign res = res_temp;
endmodule
module DIG_RAMDualPort
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
  input [(AddrBits-1):0] A,
  input [(Bits-1):0] Din,
  input str,
  input C,
  input ld,
  output [(Bits-1):0] D
);
  reg [(Bits-1):0] memory[0:((1 << AddrBits) - 1)];

  assign D = ld? memory[A] : 'hz;

  always @ (posedge C) begin
    if (str)
      memory[A] <= Din;
  end
endmodule


module Mips32SoC (
  input clk,
  input rst
);
  wire [31:0] s0;
  wire [31:0] s1;
  wire [31:0] s2;
  wire [7:0] s3;
  wire [31:0] Instr;
  wire [31:0] s4;
  wire RegWrite;
  wire [4:0] s5;
  wire [4:0] s6;
  wire [4:0] s7;
  wire [31:0] s8;
  wire [31:0] s9;
  wire [5:0] func;
  wire [4:0] s10;
  wire [5:0] s11;
  wire [31:0] s12;
  wire [2:0] s13;
  wire [31:0] s14;
  wire isZero;
  wire jump;
  wire branch;
  wire MemRead;
  wire MemWrite;
  wire MemToReg;
  wire AluSrc;
  wire RegDst;
  wire Bne;
  wire [7:0] s15;
  wire [31:0] s16;
  wire [9:0] s17;
  wire [15:0] s18;
  wire [31:0] \sign-ex ;
  wire [31:0] s19;
  wire [27:0] s20;
  wire [31:0] s21;
  wire [31:0] s22;
  wire [31:0] s23;
  wire s24;
  wire [31:0] s25;
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i0 (
    .sel( rst ),
    .in_0( s19 ),
    .in_1( 32'b0 ),
    .out( s0 )
  );
  // PC
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i1 (
    .D( s0 ),
    .C( clk ),
    .en( 1'b1 ),
    .Q( s1 )
  );
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i2 (
    .a( s1 ),
    .b( 32'b100 ),
    .c_i( 1'b0 ),
    .s( s2 )
  );
  assign s17 = s1[9:0];
  assign s3 = s17[9:2];
  // InstMem
  DIG_ROM_256X32_InstMem DIG_ROM_256X32_InstMem_i3 (
    .A( s3 ),
    .sel( 1'b1 ),
    .D( Instr )
  );
  assign s20[1:0] = 2'b0;
  assign s20[27:2] = Instr[25:0];
  assign func = Instr[5:0];
  assign s10 = Instr[15:11];
  assign s7 = Instr[20:16];
  assign s6 = Instr[25:21];
  assign s11 = Instr[31:26];
  assign s18 = Instr[15:0];
  control_unit_full control_unit_full_i4 (
    .opcode( s11 ),
    .func( func ),
    .jump( jump ),
    .Branch( branch ),
    .MemRead( MemRead ),
    .MemWrite( MemWrite ),
    .MemToReg( MemToReg ),
    .ALUSrc( AluSrc ),
    .RegWrite( RegWrite ),
    .RegDst( RegDst ),
    .ALUFunc( s13 ),
    .Bne( Bne )
  );
  DIG_BitExtender #(
    .inputBits(16),
    .outputBits(32)
  )
  DIG_BitExtender_i5 (
    .in( s18 ),
    .out( \sign-ex  )
  );
  assign s21[27:0] = s20;
  assign s21[31:28] = s2[31:28];
  Mux_2x1_NBits #(
    .Bits(5)
  )
  Mux_2x1_NBits_i6 (
    .sel( RegDst ),
    .in_0( s7 ),
    .in_1( s10 ),
    .out( s5 )
  );
  assign s22[1:0] = 2'b0;
  assign s22[31:2] = \sign-ex [29:0];
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i7 (
    .a( s2 ),
    .b( s22 ),
    .c_i( 1'b0 ),
    .s( s23 )
  );
  DIG_RegisterFile #(
    .Bits(32),
    .AddrBits(5)
  )
  DIG_RegisterFile_i8 (
    .Din( s4 ),
    .we( RegWrite ),
    .Rw( s5 ),
    .C( clk ),
    .Ra( s6 ),
    .Rb( s7 ),
    .Da( s8 ),
    .Db( s9 )
  );
  alu alu_i9 (
    .a( s8 ),
    .b( s12 ),
    .func( s13 ),
    .res( s14 ),
    .zero( isZero )
  );
  // DataMem
  DIG_RAMDualPort #(
    .Bits(32),
    .AddrBits(8)
  )
  DIG_RAMDualPort_i10 (
    .A( s15 ),
    .Din( s9 ),
    .str( MemWrite ),
    .C( clk ),
    .ld( MemRead ),
    .D( s16 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i11 (
    .sel( MemToReg ),
    .in_0( s14 ),
    .in_1( s16 ),
    .out( s4 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i12 (
    .sel( AluSrc ),
    .in_0( s9 ),
    .in_1( \sign-ex  ),
    .out( s12 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i13 (
    .sel( s24 ),
    .in_0( s2 ),
    .in_1( s23 ),
    .out( s25 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i14 (
    .sel( jump ),
    .in_0( s25 ),
    .in_1( s21 ),
    .out( s19 )
  );
  assign s24 = ((branch & isZero) | (Bne & ~ isZero));
  assign s15 = s14[9:2];
endmodule
